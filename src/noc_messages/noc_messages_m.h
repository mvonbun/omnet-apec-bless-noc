//
// Generated file, do not edit! Created by nedtool 5.0 from noc_messages/noc_messages.msg.
//

#ifndef __NOC_MESSAGES_M_H
#define __NOC_MESSAGES_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0500
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include "enum_definitions_m.h"
// }}

/**
 * Class generated from <tt>noc_messages/noc_messages.msg:33</tt> by nedtool.
 * <pre>
 * //
 * // timeout message
 * //
 * message TimeoutMsg
 * {
 *     @customize(true);
 *     kind = TIMEOUT;
 *     long packet_id;
 *     simtime_t timeout;
 * }
 * </pre>
 *
 * TimeoutMsg_Base is only useful if it gets subclassed, and TimeoutMsg is derived from it.
 * The minimum code to be written for TimeoutMsg is the following:
 *
 * <pre>
 * class TimeoutMsg : public TimeoutMsg_Base
 * {
 *   private:
 *     void copy(const TimeoutMsg& other) { ... }

 *   public:
 *     TimeoutMsg(const char *name=nullptr, int kind=0) : TimeoutMsg_Base(name,kind) {}
 *     TimeoutMsg(const TimeoutMsg& other) : TimeoutMsg_Base(other) {copy(other);}
 *     TimeoutMsg& operator=(const TimeoutMsg& other) {if (this==&other) return *this; TimeoutMsg_Base::operator=(other); copy(other); return *this;}
 *     virtual TimeoutMsg *dup() const {return new TimeoutMsg(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from TimeoutMsg_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(TimeoutMsg);
 * </pre>
 */
class TimeoutMsg_Base : public ::omnetpp::cMessage
{
  protected:
    long packet_id;
    ::omnetpp::simtime_t timeout;

  private:
    void copy(const TimeoutMsg_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TimeoutMsg_Base&);
    // make constructors protected to avoid instantiation
    TimeoutMsg_Base(const char *name=nullptr, int kind=0);
    TimeoutMsg_Base(const TimeoutMsg_Base& other);
    // make assignment operator protected to force the user override it
    TimeoutMsg_Base& operator=(const TimeoutMsg_Base& other);

  public:
    virtual ~TimeoutMsg_Base();
    virtual TimeoutMsg_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class TimeoutMsg");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual long getPacket_id() const;
    virtual void setPacket_id(long packet_id);
    virtual ::omnetpp::simtime_t getTimeout() const;
    virtual void setTimeout(::omnetpp::simtime_t timeout);
};

/**
 * Class generated from <tt>noc_messages/noc_messages.msg:43</tt> by nedtool.
 * <pre>
 * //
 * // release message
 * //
 * message ResourceReleaseMsg
 * {
 *     @customize(true);
 *     kind = RELEVENT;
 *     long message_id;
 *     int port_id;
 * }
 * </pre>
 *
 * ResourceReleaseMsg_Base is only useful if it gets subclassed, and ResourceReleaseMsg is derived from it.
 * The minimum code to be written for ResourceReleaseMsg is the following:
 *
 * <pre>
 * class ResourceReleaseMsg : public ResourceReleaseMsg_Base
 * {
 *   private:
 *     void copy(const ResourceReleaseMsg& other) { ... }

 *   public:
 *     ResourceReleaseMsg(const char *name=nullptr, int kind=0) : ResourceReleaseMsg_Base(name,kind) {}
 *     ResourceReleaseMsg(const ResourceReleaseMsg& other) : ResourceReleaseMsg_Base(other) {copy(other);}
 *     ResourceReleaseMsg& operator=(const ResourceReleaseMsg& other) {if (this==&other) return *this; ResourceReleaseMsg_Base::operator=(other); copy(other); return *this;}
 *     virtual ResourceReleaseMsg *dup() const {return new ResourceReleaseMsg(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from ResourceReleaseMsg_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(ResourceReleaseMsg);
 * </pre>
 */
class ResourceReleaseMsg_Base : public ::omnetpp::cMessage
{
  protected:
    long message_id;
    int port_id;

  private:
    void copy(const ResourceReleaseMsg_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ResourceReleaseMsg_Base&);
    // make constructors protected to avoid instantiation
    ResourceReleaseMsg_Base(const char *name=nullptr, int kind=0);
    ResourceReleaseMsg_Base(const ResourceReleaseMsg_Base& other);
    // make assignment operator protected to force the user override it
    ResourceReleaseMsg_Base& operator=(const ResourceReleaseMsg_Base& other);

  public:
    virtual ~ResourceReleaseMsg_Base();
    virtual ResourceReleaseMsg_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class ResourceReleaseMsg");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual long getMessage_id() const;
    virtual void setMessage_id(long message_id);
    virtual int getPort_id() const;
    virtual void setPort_id(int port_id);
};

/**
 * Class generated from <tt>noc_messages/noc_messages.msg:53</tt> by nedtool.
 * <pre>
 * //
 * // packet generation trigger message
 * //
 * message PacketGenerationTriggerMsg
 * {
 *     kind = PACKTRIG;
 *     int num_base_flit;
 *     int destination;
 *     int priority;
 *     num_base_flit = -1;
 *     destination = -1;
 *     priority = -1;
 * }
 * </pre>
 */
class PacketGenerationTriggerMsg : public ::omnetpp::cMessage
{
  protected:
    int num_base_flit;
    int destination;
    int priority;

  private:
    void copy(const PacketGenerationTriggerMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PacketGenerationTriggerMsg&);

  public:
    PacketGenerationTriggerMsg(const char *name=nullptr, int kind=0);
    PacketGenerationTriggerMsg(const PacketGenerationTriggerMsg& other);
    virtual ~PacketGenerationTriggerMsg();
    PacketGenerationTriggerMsg& operator=(const PacketGenerationTriggerMsg& other);
    virtual PacketGenerationTriggerMsg *dup() const {return new PacketGenerationTriggerMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getNum_base_flit() const;
    virtual void setNum_base_flit(int num_base_flit);
    virtual int getDestination() const;
    virtual void setDestination(int destination);
    virtual int getPriority() const;
    virtual void setPriority(int priority);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PacketGenerationTriggerMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PacketGenerationTriggerMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>noc_messages/noc_messages.msg:66</tt> by nedtool.
 * <pre>
 * //
 * // monitor message
 * //
 * message MonitorMsg
 * {
 *     kind = MONITOR;
 *     int module_id;
 *     int module_type;
 *     int value;
 * }
 * </pre>
 */
class MonitorMsg : public ::omnetpp::cMessage
{
  protected:
    int module_id;
    int module_type;
    int value;

  private:
    void copy(const MonitorMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MonitorMsg&);

  public:
    MonitorMsg(const char *name=nullptr, int kind=0);
    MonitorMsg(const MonitorMsg& other);
    virtual ~MonitorMsg();
    MonitorMsg& operator=(const MonitorMsg& other);
    virtual MonitorMsg *dup() const {return new MonitorMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getModule_id() const;
    virtual void setModule_id(int module_id);
    virtual int getModule_type() const;
    virtual void setModule_type(int module_type);
    virtual int getValue() const;
    virtual void setValue(int value);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MonitorMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MonitorMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>noc_messages/noc_messages.msg:76</tt> by nedtool.
 * <pre>
 * //
 * // pending buffer overflow message
 * //
 * message PBuffOverflowMsg
 * {
 *     @customize(true);
 *     kind = CBUFOVFL;
 *     schedulingPriority = SP_LAST;
 *     int module_id;
 * }
 * </pre>
 *
 * PBuffOverflowMsg_Base is only useful if it gets subclassed, and PBuffOverflowMsg is derived from it.
 * The minimum code to be written for PBuffOverflowMsg is the following:
 *
 * <pre>
 * class PBuffOverflowMsg : public PBuffOverflowMsg_Base
 * {
 *   private:
 *     void copy(const PBuffOverflowMsg& other) { ... }

 *   public:
 *     PBuffOverflowMsg(const char *name=nullptr, int kind=0) : PBuffOverflowMsg_Base(name,kind) {}
 *     PBuffOverflowMsg(const PBuffOverflowMsg& other) : PBuffOverflowMsg_Base(other) {copy(other);}
 *     PBuffOverflowMsg& operator=(const PBuffOverflowMsg& other) {if (this==&other) return *this; PBuffOverflowMsg_Base::operator=(other); copy(other); return *this;}
 *     virtual PBuffOverflowMsg *dup() const {return new PBuffOverflowMsg(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from PBuffOverflowMsg_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(PBuffOverflowMsg);
 * </pre>
 */
class PBuffOverflowMsg_Base : public ::omnetpp::cMessage
{
  protected:
    int module_id;

  private:
    void copy(const PBuffOverflowMsg_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PBuffOverflowMsg_Base&);
    // make constructors protected to avoid instantiation
    PBuffOverflowMsg_Base(const char *name=nullptr, int kind=0);
    PBuffOverflowMsg_Base(const PBuffOverflowMsg_Base& other);
    // make assignment operator protected to force the user override it
    PBuffOverflowMsg_Base& operator=(const PBuffOverflowMsg_Base& other);

  public:
    virtual ~PBuffOverflowMsg_Base();
    virtual PBuffOverflowMsg_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class PBuffOverflowMsg");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getModule_id() const;
    virtual void setModule_id(int module_id);
};

/**
 * Class generated from <tt>noc_messages/noc_messages.msg:86</tt> by nedtool.
 * <pre>
 * //
 * // convergence message
 * //
 * message ConvergenceMsg
 * {
 *     @customize(true);
 *     kind = CCONV;
 *     schedulingPriority = SP_LAST;
 *     int module_id;
 *     simtime_t avg_latency;
 * }
 * </pre>
 *
 * ConvergenceMsg_Base is only useful if it gets subclassed, and ConvergenceMsg is derived from it.
 * The minimum code to be written for ConvergenceMsg is the following:
 *
 * <pre>
 * class ConvergenceMsg : public ConvergenceMsg_Base
 * {
 *   private:
 *     void copy(const ConvergenceMsg& other) { ... }

 *   public:
 *     ConvergenceMsg(const char *name=nullptr, int kind=0) : ConvergenceMsg_Base(name,kind) {}
 *     ConvergenceMsg(const ConvergenceMsg& other) : ConvergenceMsg_Base(other) {copy(other);}
 *     ConvergenceMsg& operator=(const ConvergenceMsg& other) {if (this==&other) return *this; ConvergenceMsg_Base::operator=(other); copy(other); return *this;}
 *     virtual ConvergenceMsg *dup() const {return new ConvergenceMsg(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from ConvergenceMsg_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(ConvergenceMsg);
 * </pre>
 */
class ConvergenceMsg_Base : public ::omnetpp::cMessage
{
  protected:
    int module_id;
    ::omnetpp::simtime_t avg_latency;

  private:
    void copy(const ConvergenceMsg_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ConvergenceMsg_Base&);
    // make constructors protected to avoid instantiation
    ConvergenceMsg_Base(const char *name=nullptr, int kind=0);
    ConvergenceMsg_Base(const ConvergenceMsg_Base& other);
    // make assignment operator protected to force the user override it
    ConvergenceMsg_Base& operator=(const ConvergenceMsg_Base& other);

  public:
    virtual ~ConvergenceMsg_Base();
    virtual ConvergenceMsg_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class ConvergenceMsg");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getModule_id() const;
    virtual void setModule_id(int module_id);
    virtual ::omnetpp::simtime_t getAvg_latency() const;
    virtual void setAvg_latency(::omnetpp::simtime_t avg_latency);
};


#endif // ifndef __NOC_MESSAGES_M_H

