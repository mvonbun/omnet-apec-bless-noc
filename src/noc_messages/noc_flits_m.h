//
// Generated file, do not edit! Created by nedtool 5.0 from noc_messages/noc_flits.msg.
//

#ifndef __NOC_FLITS_M_H
#define __NOC_FLITS_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0500
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <vector>
#include <omnetpp.h>
#include "enum_definitions_m.h"
typedef std::vector<int> IntVector;
typedef std::vector<omnetpp::simtime_t> SimtimeVector;
// }}

/**
 * Class generated from <tt>noc_messages/noc_flits.msg:56</tt> by nedtool.
 * <pre>
 * //
 * // Root flit (base for all flit types).
 * //
 * packet RootFlit
 * {
 *     schedulingPriority = SP_BASE;
 *     int sequence_number;
 * }
 * </pre>
 */
class RootFlit : public ::omnetpp::cPacket
{
  protected:
    int sequence_number;

  private:
    void copy(const RootFlit& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RootFlit&);

  public:
    RootFlit(const char *name=nullptr, int kind=0);
    RootFlit(const RootFlit& other);
    virtual ~RootFlit();
    RootFlit& operator=(const RootFlit& other);
    virtual RootFlit *dup() const {return new RootFlit(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getSequence_number() const;
    virtual void setSequence_number(int sequence_number);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RootFlit& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RootFlit& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>noc_messages/noc_flits.msg:65</tt> by nedtool.
 * <pre>
 * //
 * // Body flit.
 * //
 * packet BodyFlit extends RootFlit
 * {
 *     @customize(true);
 *     kind = BODY;
 * }
 * </pre>
 *
 * BodyFlit_Base is only useful if it gets subclassed, and BodyFlit is derived from it.
 * The minimum code to be written for BodyFlit is the following:
 *
 * <pre>
 * class BodyFlit : public BodyFlit_Base
 * {
 *   private:
 *     void copy(const BodyFlit& other) { ... }

 *   public:
 *     BodyFlit(const char *name=nullptr, int kind=0) : BodyFlit_Base(name,kind) {}
 *     BodyFlit(const BodyFlit& other) : BodyFlit_Base(other) {copy(other);}
 *     BodyFlit& operator=(const BodyFlit& other) {if (this==&other) return *this; BodyFlit_Base::operator=(other); copy(other); return *this;}
 *     virtual BodyFlit *dup() const {return new BodyFlit(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from BodyFlit_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(BodyFlit);
 * </pre>
 */
class BodyFlit_Base : public ::RootFlit
{
  protected:

  private:
    void copy(const BodyFlit_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BodyFlit_Base&);
    // make constructors protected to avoid instantiation
    BodyFlit_Base(const char *name=nullptr, int kind=0);
    BodyFlit_Base(const BodyFlit_Base& other);
    // make assignment operator protected to force the user override it
    BodyFlit_Base& operator=(const BodyFlit_Base& other);

  public:
    virtual ~BodyFlit_Base();
    virtual BodyFlit_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class BodyFlit");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
};

/**
 * Class generated from <tt>noc_messages/noc_flits.msg:74</tt> by nedtool.
 * <pre>
 * //
 * // Tail flit.
 * //
 * packet TailFlit extends RootFlit
 * {
 *     @customize(true);
 *     kind = TAIL;
 * }
 * </pre>
 *
 * TailFlit_Base is only useful if it gets subclassed, and TailFlit is derived from it.
 * The minimum code to be written for TailFlit is the following:
 *
 * <pre>
 * class TailFlit : public TailFlit_Base
 * {
 *   private:
 *     void copy(const TailFlit& other) { ... }

 *   public:
 *     TailFlit(const char *name=nullptr, int kind=0) : TailFlit_Base(name,kind) {}
 *     TailFlit(const TailFlit& other) : TailFlit_Base(other) {copy(other);}
 *     TailFlit& operator=(const TailFlit& other) {if (this==&other) return *this; TailFlit_Base::operator=(other); copy(other); return *this;}
 *     virtual TailFlit *dup() const {return new TailFlit(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from TailFlit_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(TailFlit);
 * </pre>
 */
class TailFlit_Base : public ::RootFlit
{
  protected:

  private:
    void copy(const TailFlit_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TailFlit_Base&);
    // make constructors protected to avoid instantiation
    TailFlit_Base(const char *name=nullptr, int kind=0);
    TailFlit_Base(const TailFlit_Base& other);
    // make assignment operator protected to force the user override it
    TailFlit_Base& operator=(const TailFlit_Base& other);

  public:
    virtual ~TailFlit_Base();
    virtual TailFlit_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class TailFlit");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
};

/**
 * Class generated from <tt>noc_messages/noc_flits.msg:83</tt> by nedtool.
 * <pre>
 * //
 * // Header flit.
 * //
 * packet HeadFlit extends RootFlit
 * {
 *     @customize(true);
 *     // set head properties
 *     kind = HEAD;
 *     sequence_number = 0;
 * 
 *     // control info
 *     int source;
 *     int destination;
 * 
 *     // packet indentification
 *     simtime_t generation_time;
 *     simtime_t injection_time;
 *     long packet_id;  // id of a packet
 *     long message_id; // id of a message (== multiple packets)
 *     int priority;    // packet priority
 * 
 *     // packet size
 *     int num_flit;     // total number of flits
 *     int num_baseflit; // number of payload flits
 *     int num_codeflit; // number of code flits
 * 
 *     // transmission properties
 *     simtime_t timeout; // timeout until retransmission
 *     int attempts;      // number of transmission attempts
 *     // int num_hops;      // distance traveled
 * 
 *     // properties for statistics
 *     int distance;
 * }
 * </pre>
 *
 * HeadFlit_Base is only useful if it gets subclassed, and HeadFlit is derived from it.
 * The minimum code to be written for HeadFlit is the following:
 *
 * <pre>
 * class HeadFlit : public HeadFlit_Base
 * {
 *   private:
 *     void copy(const HeadFlit& other) { ... }

 *   public:
 *     HeadFlit(const char *name=nullptr, int kind=0) : HeadFlit_Base(name,kind) {}
 *     HeadFlit(const HeadFlit& other) : HeadFlit_Base(other) {copy(other);}
 *     HeadFlit& operator=(const HeadFlit& other) {if (this==&other) return *this; HeadFlit_Base::operator=(other); copy(other); return *this;}
 *     virtual HeadFlit *dup() const {return new HeadFlit(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from HeadFlit_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(HeadFlit);
 * </pre>
 */
class HeadFlit_Base : public ::RootFlit
{
  protected:
    int source;
    int destination;
    ::omnetpp::simtime_t generation_time;
    ::omnetpp::simtime_t injection_time;
    long packet_id;
    long message_id;
    int priority;
    int num_flit;
    int num_baseflit;
    int num_codeflit;
    ::omnetpp::simtime_t timeout;
    int attempts;
    int distance;

  private:
    void copy(const HeadFlit_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HeadFlit_Base&);
    // make constructors protected to avoid instantiation
    HeadFlit_Base(const char *name=nullptr, int kind=0);
    HeadFlit_Base(const HeadFlit_Base& other);
    // make assignment operator protected to force the user override it
    HeadFlit_Base& operator=(const HeadFlit_Base& other);

  public:
    virtual ~HeadFlit_Base();
    virtual HeadFlit_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class HeadFlit");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getSource() const;
    virtual void setSource(int source);
    virtual int getDestination() const;
    virtual void setDestination(int destination);
    virtual ::omnetpp::simtime_t getGeneration_time() const;
    virtual void setGeneration_time(::omnetpp::simtime_t generation_time);
    virtual ::omnetpp::simtime_t getInjection_time() const;
    virtual void setInjection_time(::omnetpp::simtime_t injection_time);
    virtual long getPacket_id() const;
    virtual void setPacket_id(long packet_id);
    virtual long getMessage_id() const;
    virtual void setMessage_id(long message_id);
    virtual int getPriority() const;
    virtual void setPriority(int priority);
    virtual int getNum_flit() const;
    virtual void setNum_flit(int num_flit);
    virtual int getNum_baseflit() const;
    virtual void setNum_baseflit(int num_baseflit);
    virtual int getNum_codeflit() const;
    virtual void setNum_codeflit(int num_codeflit);
    virtual ::omnetpp::simtime_t getTimeout() const;
    virtual void setTimeout(::omnetpp::simtime_t timeout);
    virtual int getAttempts() const;
    virtual void setAttempts(int attempts);
    virtual int getDistance() const;
    virtual void setDistance(int distance);
};

/**
 * Class generated from <tt>noc_messages/noc_flits.msg:118</tt> by nedtool.
 * <pre>
 * //
 * // Ack.
 * //
 * packet AckFlit extends RootFlit
 * {
 *     @customize(true);
 *     // set ack properties
 *     schedulingPriority = SP_EARLIER;
 *     kind = ACK;
 *     sequence_number = 0;
 * 
 *     // control info
 *     int source;
 *     int destination;
 * 
 *     // ack properties
 *     simtime_t generation_time;
 *     simtime_t injection_time;
 * 
 *     // acked packet properties
 *     int packet_priority;  // packet priority
 *     long packet_id;       // packet id
 *     int packet_attempts;  // attempts so far
 *     int packet_num_flit;  // packet size
 *     simtime_t packet_generation_time;
 *     simtime_t packet_injection_time;
 * }
 * </pre>
 *
 * AckFlit_Base is only useful if it gets subclassed, and AckFlit is derived from it.
 * The minimum code to be written for AckFlit is the following:
 *
 * <pre>
 * class AckFlit : public AckFlit_Base
 * {
 *   private:
 *     void copy(const AckFlit& other) { ... }

 *   public:
 *     AckFlit(const char *name=nullptr, int kind=0) : AckFlit_Base(name,kind) {}
 *     AckFlit(const AckFlit& other) : AckFlit_Base(other) {copy(other);}
 *     AckFlit& operator=(const AckFlit& other) {if (this==&other) return *this; AckFlit_Base::operator=(other); copy(other); return *this;}
 *     virtual AckFlit *dup() const {return new AckFlit(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from AckFlit_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(AckFlit);
 * </pre>
 */
class AckFlit_Base : public ::RootFlit
{
  protected:
    int source;
    int destination;
    ::omnetpp::simtime_t generation_time;
    ::omnetpp::simtime_t injection_time;
    int packet_priority;
    long packet_id;
    int packet_attempts;
    int packet_num_flit;
    ::omnetpp::simtime_t packet_generation_time;
    ::omnetpp::simtime_t packet_injection_time;

  private:
    void copy(const AckFlit_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AckFlit_Base&);
    // make constructors protected to avoid instantiation
    AckFlit_Base(const char *name=nullptr, int kind=0);
    AckFlit_Base(const AckFlit_Base& other);
    // make assignment operator protected to force the user override it
    AckFlit_Base& operator=(const AckFlit_Base& other);

  public:
    virtual ~AckFlit_Base();
    virtual AckFlit_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class AckFlit");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getSource() const;
    virtual void setSource(int source);
    virtual int getDestination() const;
    virtual void setDestination(int destination);
    virtual ::omnetpp::simtime_t getGeneration_time() const;
    virtual void setGeneration_time(::omnetpp::simtime_t generation_time);
    virtual ::omnetpp::simtime_t getInjection_time() const;
    virtual void setInjection_time(::omnetpp::simtime_t injection_time);
    virtual int getPacket_priority() const;
    virtual void setPacket_priority(int packet_priority);
    virtual long getPacket_id() const;
    virtual void setPacket_id(long packet_id);
    virtual int getPacket_attempts() const;
    virtual void setPacket_attempts(int packet_attempts);
    virtual int getPacket_num_flit() const;
    virtual void setPacket_num_flit(int packet_num_flit);
    virtual ::omnetpp::simtime_t getPacket_generation_time() const;
    virtual void setPacket_generation_time(::omnetpp::simtime_t packet_generation_time);
    virtual ::omnetpp::simtime_t getPacket_injection_time() const;
    virtual void setPacket_injection_time(::omnetpp::simtime_t packet_injection_time);
};

/**
 * Class generated from <tt>noc_messages/noc_flits.msg:145</tt> by nedtool.
 * <pre>
 * //
 * // Nack.
 * //
 * packet NackFlit extends RootFlit
 * {
 *     @customize(true);
 *  	// set nack properties
 *     schedulingPriority = SP_EARLIER;
 *     kind = NACK;
 *     sequence_number = 0;
 * 
 *     // control info
 *     int source;
 *     int destination;
 * 
 *     // nack properties
 *     simtime_t generation_time;
 *     simtime_t injection_time;
 * 
 *     // nacked packet properties
 *     int packet_priority;  // packet priority
 *     long packet_id;       // packet id
 *     int packet_attempts;  // attempts so far
 *     int packet_num_flit;  // packet size
 *     simtime_t packet_generation_time;
 *     simtime_t packet_injection_time;
 * 
 *     // nack missing data notification capability
 *     bool carries_decoder_info; // indicate if the nack carries information of missing flits
 *     IntVector missing_flits;   // decoder info of missing flits
 * 
 * }
 * </pre>
 *
 * NackFlit_Base is only useful if it gets subclassed, and NackFlit is derived from it.
 * The minimum code to be written for NackFlit is the following:
 *
 * <pre>
 * class NackFlit : public NackFlit_Base
 * {
 *   private:
 *     void copy(const NackFlit& other) { ... }

 *   public:
 *     NackFlit(const char *name=nullptr, int kind=0) : NackFlit_Base(name,kind) {}
 *     NackFlit(const NackFlit& other) : NackFlit_Base(other) {copy(other);}
 *     NackFlit& operator=(const NackFlit& other) {if (this==&other) return *this; NackFlit_Base::operator=(other); copy(other); return *this;}
 *     virtual NackFlit *dup() const {return new NackFlit(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from NackFlit_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(NackFlit);
 * </pre>
 */
class NackFlit_Base : public ::RootFlit
{
  protected:
    int source;
    int destination;
    ::omnetpp::simtime_t generation_time;
    ::omnetpp::simtime_t injection_time;
    int packet_priority;
    long packet_id;
    int packet_attempts;
    int packet_num_flit;
    ::omnetpp::simtime_t packet_generation_time;
    ::omnetpp::simtime_t packet_injection_time;
    bool carries_decoder_info;
    IntVector missing_flits;

  private:
    void copy(const NackFlit_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NackFlit_Base&);
    // make constructors protected to avoid instantiation
    NackFlit_Base(const char *name=nullptr, int kind=0);
    NackFlit_Base(const NackFlit_Base& other);
    // make assignment operator protected to force the user override it
    NackFlit_Base& operator=(const NackFlit_Base& other);

  public:
    virtual ~NackFlit_Base();
    virtual NackFlit_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class NackFlit");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getSource() const;
    virtual void setSource(int source);
    virtual int getDestination() const;
    virtual void setDestination(int destination);
    virtual ::omnetpp::simtime_t getGeneration_time() const;
    virtual void setGeneration_time(::omnetpp::simtime_t generation_time);
    virtual ::omnetpp::simtime_t getInjection_time() const;
    virtual void setInjection_time(::omnetpp::simtime_t injection_time);
    virtual int getPacket_priority() const;
    virtual void setPacket_priority(int packet_priority);
    virtual long getPacket_id() const;
    virtual void setPacket_id(long packet_id);
    virtual int getPacket_attempts() const;
    virtual void setPacket_attempts(int packet_attempts);
    virtual int getPacket_num_flit() const;
    virtual void setPacket_num_flit(int packet_num_flit);
    virtual ::omnetpp::simtime_t getPacket_generation_time() const;
    virtual void setPacket_generation_time(::omnetpp::simtime_t packet_generation_time);
    virtual ::omnetpp::simtime_t getPacket_injection_time() const;
    virtual void setPacket_injection_time(::omnetpp::simtime_t packet_injection_time);
    virtual bool getCarries_decoder_info() const;
    virtual void setCarries_decoder_info(bool carries_decoder_info);
    virtual IntVector& getMissing_flits();
    virtual const IntVector& getMissing_flits() const {return const_cast<NackFlit_Base*>(this)->getMissing_flits();}
    virtual void setMissing_flits(const IntVector& missing_flits);
};

/**
 * Class generated from <tt>noc_messages/noc_flits.msg:177</tt> by nedtool.
 * <pre>
 * //
 * // Combined Nack.
 * //
 * packet CNackFlit extends RootFlit
 * {
 *     @customize(true);
 *     // set nack properties
 *     schedulingPriority = SP_EARLIER;
 *     kind = CNACK;
 *     sequence_number = 0;
 *     int num_nacks_combined = 0;
 * }
 * </pre>
 *
 * CNackFlit_Base is only useful if it gets subclassed, and CNackFlit is derived from it.
 * The minimum code to be written for CNackFlit is the following:
 *
 * <pre>
 * class CNackFlit : public CNackFlit_Base
 * {
 *   private:
 *     void copy(const CNackFlit& other) { ... }

 *   public:
 *     CNackFlit(const char *name=nullptr, int kind=0) : CNackFlit_Base(name,kind) {}
 *     CNackFlit(const CNackFlit& other) : CNackFlit_Base(other) {copy(other);}
 *     CNackFlit& operator=(const CNackFlit& other) {if (this==&other) return *this; CNackFlit_Base::operator=(other); copy(other); return *this;}
 *     virtual CNackFlit *dup() const {return new CNackFlit(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from CNackFlit_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(CNackFlit);
 * </pre>
 */
class CNackFlit_Base : public ::RootFlit
{
  protected:
    int num_nacks_combined;

  private:
    void copy(const CNackFlit_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CNackFlit_Base&);
    // make constructors protected to avoid instantiation
    CNackFlit_Base(const char *name=nullptr, int kind=0);
    CNackFlit_Base(const CNackFlit_Base& other);
    // make assignment operator protected to force the user override it
    CNackFlit_Base& operator=(const CNackFlit_Base& other);

  public:
    virtual ~CNackFlit_Base();
    virtual CNackFlit_Base *dup() const {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class CNackFlit");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int getNum_nacks_combined() const;
    virtual void setNum_nacks_combined(int num_nacks_combined);
};


#endif // ifndef __NOC_FLITS_M_H

